// SPDX-License-Identifier: GPL-2.0
/* Driver for UltraRISC Core PVT
 *
 * Copyright(C) 2025 UltraRISC Technology (Shanghai) Co., Ltd.
 *
 * Author:  wangjia <wangjia@ultrarisc.com>
 */

#include <linux/device.h>
#include <linux/module.h>
#include <linux/hwmon-sysfs.h>
#include <linux/hwmon.h>
#include <linux/of.h>
#include <linux/platform_device.h>
#include <linux/types.h>
#include <linux/io.h>

#define COREPVT_CHL_OFFSET	0x1000
#define COREPVT_REG_CIR		0x0
#define COREPVT_REG_PSCR	0x04
#define COREPVT_REG_CFDR	0x08
#define COREPVT_REG_DOR		0x0C
#define COREPVT_REG_ICR		0x10
#define COREPVT_REG_IER		0x14
#define COREPVT_REG_IMSR	0x18
#define COREPVT_REG_IRSR	0x1C

#define PVT_MAX_CHANNEL		64
#define PVT_TRIM_DEFAULT	0x7

struct corepvt_channel_config {
	const char *label;
	u32 trim;
};

struct corepvt_cal_data {
	u32 val_offset;
	u32 val_lsb;
};

struct corepvt_data {
	const struct hwmon_chip_info *chip_info;
	u64 temp_chl_mask;
	u64 vol_chl_mask;
};

struct corepvt_hwmon {
	struct device *dev;
	struct device *hwmon;

	void __iomem *regs;
	int irq;
	int clk_freq;
	int channels;
	const struct hwmon_chip_info *chip_info;
	struct corepvt_channel_config config[PVT_MAX_CHANNEL];
	const struct corepvt_data *pvt_data;
	raw_spinlock_t lock;
};

#define COREPVT_VOLTAGE_DATA_BASE	2065100	/* 2065.1 */
#define COREPVT_VOLTAGE_LSB		1682	/* 1.682 mV */
#define COREPVT_TEMP_DATA_BASE		27049000 /* 2704.9 */
#define COREPVT_TEMP_LSB		22632	/* 2.2632 Celsius */

static int corepvt_read_vol(struct corepvt_hwmon *pvt,
			    int channel, long *val)
{
	void __iomem *chl_base;
	unsigned long flag;
	u32 dout;
	u32 chl_offset = 0;

	// Assume that the voltage channel is continuous
	chl_offset = __ffs64(pvt->pvt_data->vol_chl_mask);
	chl_base = pvt->regs + COREPVT_CHL_OFFSET * (channel + chl_offset);

	raw_spin_lock_irqsave(&pvt->lock, flag);
	dout = readl_relaxed(chl_base + COREPVT_REG_DOR);
	raw_spin_unlock_irqrestore(&pvt->lock, flag);

	*val = ((long)dout * 1000 - COREPVT_VOLTAGE_DATA_BASE) / COREPVT_VOLTAGE_LSB;

	return 0;
}

static int corepvt_read_temp(struct corepvt_hwmon *pvt,
			     int channel, long *val)
{
	void __iomem *chl_base;
	unsigned long flag;
	u32 dout;
	u32 chl_offset = 0;

	// Assume that the temperature channel is continuous
	chl_offset = __ffs64(pvt->pvt_data->temp_chl_mask);
	chl_base = pvt->regs + COREPVT_CHL_OFFSET * (channel + chl_offset);

	raw_spin_lock_irqsave(&pvt->lock, flag);
	dout = readl_relaxed(chl_base + COREPVT_REG_DOR);
	raw_spin_unlock_irqrestore(&pvt->lock, flag);

	*val = ((long)dout * 10000 - COREPVT_TEMP_DATA_BASE) * 1000 / COREPVT_TEMP_LSB;

	return 0;
}

static umode_t corepvt_is_visible(const void *drvdata, enum hwmon_sensor_types type,
				  u32 attr, int channel)
{
	const struct corepvt_hwmon *pvt = drvdata;

	if (channel >= pvt->channels)
		return 0;

	switch (type) {
	case hwmon_in:
		switch (attr) {
		case hwmon_in_input:
		case hwmon_in_label:
			return 0444;
		}
	break;
	case hwmon_temp:
		switch (attr) {
		case hwmon_temp_input:
		case hwmon_temp_type:
		case hwmon_temp_label:
			return 0444;
		}
	break;
	default:
		return 0;
	}

	return 0;
}

static int corepvt_read(struct device *dev, enum hwmon_sensor_types type,
			u32 attr, int channel, long *val)
{
	struct corepvt_hwmon *pvt = dev_get_drvdata(dev);

	switch (type) {
	case hwmon_in:
		switch (attr) {
		case hwmon_in_input:
			return corepvt_read_vol(pvt, channel, val);
		}
	break;
	case hwmon_temp:
		switch (attr) {
		case hwmon_temp_type:
			*val = 1;
			return 0;
		case hwmon_temp_input:
			return corepvt_read_temp(pvt, channel, val);
		}
	break;
	default:
		return -EOPNOTSUPP;
	}

	return -ENODATA;
}

static int corepvt_read_string(struct device *dev, enum hwmon_sensor_types type,
			       u32 attr, int channel, const char **str)
{
	struct corepvt_hwmon *pvt = dev_get_drvdata(dev);
	u32 chl_offset = 0;

	switch (type) {
	case hwmon_in:
		chl_offset = __ffs64(pvt->pvt_data->vol_chl_mask);
	break;
	case hwmon_temp:
		chl_offset = __ffs64(pvt->pvt_data->temp_chl_mask);
	break;
	default:
		return -ENODATA;
	break;
	}

	*str = pvt->config[channel + chl_offset].label;

	return 0;
}

/*
 * corepvt init process:
 *	1. config SETUP time, should be 10us, set PSCR register
 *	2. config CLKIN, should be 4MHz, set CFDR register
 *	3. (TODO)config interrupt, set ICR/IER/IMSR/IRSR
 *	4. config TRIM and enable PVT, set CIR
 */
static int corepvt_init(struct corepvt_hwmon *pvt)
{
	void __iomem *chl_base;
	unsigned long flag;
	/*
	 * SETUP time 10us = 100KHz
	 * PSCR = CLK_FREQ / 100KHz
	 */
	u32 pscr_val = pvt->clk_freq / 100000;
	/*
	 * CFDR = CLK_FREQ / 4MHz / 2
	 */
	u32 cfdr_val = pvt->clk_freq / 8000000;
	/*
	 * CIR:
	 *	bit[0]: PU_VTDC, set 1 to enable pvt
	 *	bit[5:2]: TRIM
	 */
	u32 cir_val;

	raw_spin_lock_irqsave(&pvt->lock, flag);
	for (int i = 0; i < pvt->channels; i++) {
		chl_base = pvt->regs + COREPVT_CHL_OFFSET * i;
		cir_val = (pvt->config[i].trim << 2) | 0x01;
		writel_relaxed(pscr_val, chl_base + COREPVT_REG_PSCR);
		writel_relaxed(cfdr_val, chl_base + COREPVT_REG_CFDR);
		writel_relaxed(cir_val, chl_base + COREPVT_REG_CIR);
	}
	raw_spin_unlock_irqrestore(&pvt->lock, flag);

	return 0;
}

static const struct hwmon_ops corepvt_hwmon_ops = {
	.is_visible = corepvt_is_visible,
	.read = corepvt_read,
	.read_string = corepvt_read_string,
};

static int corepvt_probe_channel_from_dt(struct platform_device *pdev, struct corepvt_hwmon *pvt)
{
	struct device_node *child;
	int ret;
	u32 channel;
	const char *label;
	u32 trim;

	for_each_child_of_node(pdev->dev.of_node, child) {
		if (!of_node_name_eq(child, "channel"))
			continue;

		ret = of_property_read_u32(child, "reg", &channel);
		if (ret)
			goto node_put;

		ret = of_property_read_string(child, "label", &label);
		if (ret)
			goto node_put;

		if (of_property_present(child, "trim"))
			of_property_read_u32(child, "trim", &trim);
		else
			trim = PVT_TRIM_DEFAULT;

		pvt->config[channel].label = label;
		pvt->config[channel].trim = trim;
	}

	return 0;

node_put:
	of_node_put(child);
	return ret;
}

static int corepvt_probe(struct platform_device *pdev)
{
	struct corepvt_hwmon *pvt;
	const struct corepvt_data *pvt_data;
	int ret;

	pvt = devm_kzalloc(&pdev->dev, sizeof(*pvt), GFP_KERNEL);
	if (!pvt)
		return -ENOMEM;

	pvt->regs = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pvt->regs)) {
		dev_err(&pdev->dev, "get ioremap resource failed\n");
		ret = -EINVAL;
		goto free_pvt;
	}

	if (device_property_present(&pdev->dev, "interrupts"))
		pvt->irq = platform_get_irq(pdev, 0);

	ret = device_property_read_u32(&pdev->dev, "clock-frequency", &pvt->clk_freq);
	if (ret) {
		dev_err(&pdev->dev, "get clock-frequency failed\n");
		goto free_pvt;
	}

	ret = device_property_read_u32(&pdev->dev, "channels", &pvt->channels);
	if (ret) {
		dev_err(&pdev->dev, "get channels failed\n");
		goto free_pvt;
	}

	pvt_data = device_get_match_data(&pdev->dev);
	if (!pvt_data) {
		dev_err(&pdev->dev, "No chip info found\n");
		ret = -ENODATA;
		goto free_pvt;
	}

	pvt->dev = &pdev->dev;
	pvt->chip_info = pvt_data->chip_info;
	pvt->pvt_data = pvt_data;

	if (pdev->dev.of_node) {
		ret = corepvt_probe_channel_from_dt(pdev, pvt);
		if (ret)
			dev_warn(&pdev->dev, "WARN: probe channel failed\n");
	}

	pvt->hwmon = devm_hwmon_device_register_with_info(&pdev->dev, "corepvt_ultrarisc",
							  pvt, pvt->chip_info,
							  NULL);
	if (IS_ERR(pvt->hwmon)) {
		dev_err(&pdev->dev, "register hwmon failed(%ld)\n", PTR_ERR(pvt->hwmon));
		ret = -EINVAL;
		goto free_pvt;
	}

	pvt->dev = &pdev->dev;
	raw_spin_lock_init(&pvt->lock);

	// Config and enable corepvt
	corepvt_init(pvt);

	return 0;

free_pvt:
	devm_kfree(&pdev->dev, pvt);
	return ret;
}

static const struct hwmon_channel_info * const ur_dp1000_channel_info[] = {
	HWMON_CHANNEL_INFO(temp,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL,
			   HWMON_T_INPUT | HWMON_T_LABEL),
	HWMON_CHANNEL_INFO(in,
			   HWMON_I_INPUT | HWMON_I_LABEL,
			   HWMON_I_INPUT | HWMON_I_LABEL),
	NULL
};

static const struct hwmon_chip_info ur_dp1000_chip_info = {
	.ops = &corepvt_hwmon_ops,
	.info = ur_dp1000_channel_info,
};

static struct corepvt_data ur_dp1000_pvt_data = {
	.chip_info = &ur_dp1000_chip_info,
	.temp_chl_mask = GENMASK_ULL(10, 0),
	.vol_chl_mask = GENMASK_ULL(12, 11)
};

static const struct of_device_id corepvt_of_match[] = {
	{ .compatible = "ultrarisc,dp1000-pvt", .data = &ur_dp1000_pvt_data },
	{ }
};
MODULE_DEVICE_TABLE(of, corepvt_of_match);

static struct platform_driver corepvt_driver = {
	.probe = corepvt_probe,
	.driver = {
		.name = "corepvt-ultrarisc",
		.of_match_table = corepvt_of_match
	}
};
module_platform_driver(corepvt_driver);

MODULE_AUTHOR("Jia Wang <wangjia@ultrarisc.com>");
MODULE_DESCRIPTION("corepvt-ultrarisc driver");
MODULE_LICENSE("GPL");
